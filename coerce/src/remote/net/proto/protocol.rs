// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct RemoteNode {
    // message fields
    pub node_id: ::std::string::String,
    pub addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteNode {
    fn default() -> &'a RemoteNode {
        <RemoteNode as ::protobuf::Message>::default_instance()
    }
}

impl RemoteNode {
    pub fn new() -> RemoteNode {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    // string addr = 2;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoteNode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteNode {
        RemoteNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &RemoteNode| { &m.node_id },
                |m: &mut RemoteNode| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &RemoteNode| { &m.addr },
                |m: &mut RemoteNode| { &mut m.addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteNode>(
                "RemoteNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteNode {
        static instance: ::protobuf::rt::LazyV2<RemoteNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteNode::new)
    }
}

impl ::protobuf::Clear for RemoteNode {
    fn clear(&mut self) {
        self.node_id.clear();
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientHandshake {
    // message fields
    pub node_id: ::std::string::String,
    pub nodes: ::protobuf::RepeatedField<RemoteNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientHandshake {
    fn default() -> &'a ClientHandshake {
        <ClientHandshake as ::protobuf::Message>::default_instance()
    }
}

impl ClientHandshake {
    pub fn new() -> ClientHandshake {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    // repeated .protocol.RemoteNode nodes = 2;


    pub fn get_nodes(&self) -> &[RemoteNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<RemoteNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<RemoteNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<RemoteNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClientHandshake {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        for v in &self.nodes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientHandshake {
        ClientHandshake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &ClientHandshake| { &m.node_id },
                |m: &mut ClientHandshake| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteNode>>(
                "nodes",
                |m: &ClientHandshake| { &m.nodes },
                |m: &mut ClientHandshake| { &mut m.nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientHandshake>(
                "ClientHandshake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientHandshake {
        static instance: ::protobuf::rt::LazyV2<ClientHandshake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientHandshake::new)
    }
}

impl ::protobuf::Clear for ClientHandshake {
    fn clear(&mut self) {
        self.node_id.clear();
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientHandshake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientResult {
    // message fields
    pub message_id: ::std::string::String,
    pub result: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientResult {
    fn default() -> &'a ClientResult {
        <ClientResult as ::protobuf::Message>::default_instance()
    }
}

impl ClientResult {
    pub fn new() -> ClientResult {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // bytes result = 2;


    pub fn get_result(&self) -> &[u8] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<u8>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ClientResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.result.is_empty() {
            os.write_bytes(2, &self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientResult {
        ClientResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &ClientResult| { &m.message_id },
                |m: &mut ClientResult| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "result",
                |m: &ClientResult| { &m.result },
                |m: &mut ClientResult| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientResult>(
                "ClientResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientResult {
        static instance: ::protobuf::rt::LazyV2<ClientResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientResult::new)
    }
}

impl ::protobuf::Clear for ClientResult {
    fn clear(&mut self) {
        self.message_id.clear();
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientErr {
    // message fields
    pub message_id: ::std::string::String,
    pub code: ClientErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientErr {
    fn default() -> &'a ClientErr {
        <ClientErr as ::protobuf::Message>::default_instance()
    }
}

impl ClientErr {
    pub fn new() -> ClientErr {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // .protocol.ClientErrorCode code = 2;


    pub fn get_code(&self) -> ClientErrorCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = ClientErrorCode::ActorUnavailable;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ClientErrorCode) {
        self.code = v;
    }
}

impl ::protobuf::Message for ClientErr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if self.code != ClientErrorCode::ActorUnavailable {
            my_size += ::protobuf::rt::enum_size(2, self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if self.code != ClientErrorCode::ActorUnavailable {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientErr {
        ClientErr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &ClientErr| { &m.message_id },
                |m: &mut ClientErr| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientErrorCode>>(
                "code",
                |m: &ClientErr| { &m.code },
                |m: &mut ClientErr| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientErr>(
                "ClientErr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientErr {
        static instance: ::protobuf::rt::LazyV2<ClientErr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientErr::new)
    }
}

impl ::protobuf::Clear for ClientErr {
    fn clear(&mut self) {
        self.message_id.clear();
        self.code = ClientErrorCode::ActorUnavailable;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientErr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientErr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub message_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &Ping| { &m.message_id },
                |m: &mut Ping| { &mut m.message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pong {
    // message fields
    pub message_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &Pong| { &m.message_id },
                |m: &mut Pong| { &mut m.message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pong>(
                "Pong",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pong {
        static instance: ::protobuf::rt::LazyV2<Pong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pong::new)
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateActor {
    // message fields
    pub message_id: ::std::string::String,
    pub actor_id: ::std::string::String,
    pub actor_type: ::std::string::String,
    pub recipe: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateActor {
    fn default() -> &'a CreateActor {
        <CreateActor as ::protobuf::Message>::default_instance()
    }
}

impl CreateActor {
    pub fn new() -> CreateActor {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string actor_id = 2;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // string actor_type = 3;


    pub fn get_actor_type(&self) -> &str {
        &self.actor_type
    }
    pub fn clear_actor_type(&mut self) {
        self.actor_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_type(&mut self, v: ::std::string::String) {
        self.actor_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_type(&mut self) -> &mut ::std::string::String {
        &mut self.actor_type
    }

    // Take field
    pub fn take_actor_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_type, ::std::string::String::new())
    }

    // bytes recipe = 4;


    pub fn get_recipe(&self) -> &[u8] {
        &self.recipe
    }
    pub fn clear_recipe(&mut self) {
        self.recipe.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipe(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipe = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipe(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.recipe
    }

    // Take field
    pub fn take_recipe(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.recipe, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreateActor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.recipe)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.actor_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_type);
        }
        if !self.recipe.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.recipe);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.actor_type.is_empty() {
            os.write_string(3, &self.actor_type)?;
        }
        if !self.recipe.is_empty() {
            os.write_bytes(4, &self.recipe)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateActor {
        CreateActor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &CreateActor| { &m.message_id },
                |m: &mut CreateActor| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &CreateActor| { &m.actor_id },
                |m: &mut CreateActor| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_type",
                |m: &CreateActor| { &m.actor_type },
                |m: &mut CreateActor| { &mut m.actor_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "recipe",
                |m: &CreateActor| { &m.recipe },
                |m: &mut CreateActor| { &mut m.recipe },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateActor>(
                "CreateActor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateActor {
        static instance: ::protobuf::rt::LazyV2<CreateActor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateActor::new)
    }
}

impl ::protobuf::Clear for CreateActor {
    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.actor_type.clear();
        self.recipe.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateActor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateActor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FindActor {
    // message fields
    pub message_id: ::std::string::String,
    pub actor_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FindActor {
    fn default() -> &'a FindActor {
        <FindActor as ::protobuf::Message>::default_instance()
    }
}

impl FindActor {
    pub fn new() -> FindActor {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string actor_id = 2;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FindActor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FindActor {
        FindActor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &FindActor| { &m.message_id },
                |m: &mut FindActor| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &FindActor| { &m.actor_id },
                |m: &mut FindActor| { &mut m.actor_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FindActor>(
                "FindActor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FindActor {
        static instance: ::protobuf::rt::LazyV2<FindActor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FindActor::new)
    }
}

impl ::protobuf::Clear for FindActor {
    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FindActor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FindActor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorAddress {
    // message fields
    pub actor_id: ::std::string::String,
    pub node_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorAddress {
    fn default() -> &'a ActorAddress {
        <ActorAddress as ::protobuf::Message>::default_instance()
    }
}

impl ActorAddress {
    pub fn new() -> ActorAddress {
        ::std::default::Default::default()
    }

    // string actor_id = 1;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // string node_id = 2;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActorAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.actor_id);
        }
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actor_id.is_empty() {
            os.write_string(1, &self.actor_id)?;
        }
        if !self.node_id.is_empty() {
            os.write_string(2, &self.node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorAddress {
        ActorAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &ActorAddress| { &m.actor_id },
                |m: &mut ActorAddress| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &ActorAddress| { &m.node_id },
                |m: &mut ActorAddress| { &mut m.node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorAddress>(
                "ActorAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorAddress {
        static instance: ::protobuf::rt::LazyV2<ActorAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorAddress::new)
    }
}

impl ::protobuf::Clear for ActorAddress {
    fn clear(&mut self) {
        self.actor_id.clear();
        self.node_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRequest {
    // message fields
    pub message_id: ::std::string::String,
    pub handler_type: ::std::string::String,
    pub actor_id: ::std::string::String,
    pub message: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRequest {
    fn default() -> &'a MessageRequest {
        <MessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageRequest {
    pub fn new() -> MessageRequest {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string handler_type = 2;


    pub fn get_handler_type(&self) -> &str {
        &self.handler_type
    }
    pub fn clear_handler_type(&mut self) {
        self.handler_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_handler_type(&mut self, v: ::std::string::String) {
        self.handler_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler_type(&mut self) -> &mut ::std::string::String {
        &mut self.handler_type
    }

    // Take field
    pub fn take_handler_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handler_type, ::std::string::String::new())
    }

    // string actor_id = 3;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // bytes message = 4;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handler_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.handler_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handler_type);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_id);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.handler_type.is_empty() {
            os.write_string(2, &self.handler_type)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(3, &self.actor_id)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(4, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRequest {
        MessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &MessageRequest| { &m.message_id },
                |m: &mut MessageRequest| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "handler_type",
                |m: &MessageRequest| { &m.handler_type },
                |m: &mut MessageRequest| { &mut m.handler_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &MessageRequest| { &m.actor_id },
                |m: &mut MessageRequest| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &MessageRequest| { &m.message },
                |m: &mut MessageRequest| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRequest>(
                "MessageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageRequest {
        static instance: ::protobuf::rt::LazyV2<MessageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageRequest::new)
    }
}

impl ::protobuf::Clear for MessageRequest {
    fn clear(&mut self) {
        self.message_id.clear();
        self.handler_type.clear();
        self.actor_id.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionHandshake {
    // message fields
    pub node_id: ::std::string::String,
    pub nodes: ::protobuf::RepeatedField<RemoteNode>,
    pub token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionHandshake {
    fn default() -> &'a SessionHandshake {
        <SessionHandshake as ::protobuf::Message>::default_instance()
    }
}

impl SessionHandshake {
    pub fn new() -> SessionHandshake {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    // repeated .protocol.RemoteNode nodes = 2;


    pub fn get_nodes(&self) -> &[RemoteNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<RemoteNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<RemoteNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<RemoteNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // bytes token = 3;


    pub fn get_token(&self) -> &[u8] {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SessionHandshake {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        for v in &self.nodes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.token.is_empty() {
            os.write_bytes(3, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionHandshake {
        SessionHandshake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &SessionHandshake| { &m.node_id },
                |m: &mut SessionHandshake| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteNode>>(
                "nodes",
                |m: &SessionHandshake| { &m.nodes },
                |m: &mut SessionHandshake| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &SessionHandshake| { &m.token },
                |m: &mut SessionHandshake| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionHandshake>(
                "SessionHandshake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionHandshake {
        static instance: ::protobuf::rt::LazyV2<SessionHandshake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionHandshake::new)
    }
}

impl ::protobuf::Clear for SessionHandshake {
    fn clear(&mut self) {
        self.node_id.clear();
        self.nodes.clear();
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionHandshake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Event {
    Exit = 0,
    Handshake = 1,
    Result = 2,
    Err = 3,
    Ping = 4,
    Pong = 5,
    CreateActor = 6,
    FindActor = 7,
    RegisterActor = 8,
}

impl ::protobuf::ProtobufEnum for Event {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event> {
        match value {
            0 => ::std::option::Option::Some(Event::Exit),
            1 => ::std::option::Option::Some(Event::Handshake),
            2 => ::std::option::Option::Some(Event::Result),
            3 => ::std::option::Option::Some(Event::Err),
            4 => ::std::option::Option::Some(Event::Ping),
            5 => ::std::option::Option::Some(Event::Pong),
            6 => ::std::option::Option::Some(Event::CreateActor),
            7 => ::std::option::Option::Some(Event::FindActor),
            8 => ::std::option::Option::Some(Event::RegisterActor),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Event] = &[
            Event::Exit,
            Event::Handshake,
            Event::Result,
            Event::Err,
            Event::Ping,
            Event::Pong,
            Event::CreateActor,
            Event::FindActor,
            Event::RegisterActor,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Event>("Event", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Event {
}

impl ::std::default::Default for Event {
    fn default() -> Self {
        Event::Exit
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientErrorCode {
    ActorUnavailable = 0,
    ProcessingFailed = 1,
}

impl ::protobuf::ProtobufEnum for ClientErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ClientErrorCode::ActorUnavailable),
            1 => ::std::option::Option::Some(ClientErrorCode::ProcessingFailed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientErrorCode] = &[
            ClientErrorCode::ActorUnavailable,
            ClientErrorCode::ProcessingFailed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClientErrorCode>("ClientErrorCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClientErrorCode {
}

impl ::std::default::Default for ClientErrorCode {
    fn default() -> Self {
        ClientErrorCode::ActorUnavailable
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eprotocol.proto\x12\x08protocol\"?\n\nRemoteNode\x12\x19\n\x07node_\
    id\x18\x01\x20\x01(\tR\x06nodeIdB\0\x12\x14\n\x04addr\x18\x02\x20\x01(\t\
    R\x04addrB\0:\0\"\\\n\x0fClientHandshake\x12\x19\n\x07node_id\x18\x01\
    \x20\x01(\tR\x06nodeIdB\0\x12,\n\x05nodes\x18\x02\x20\x03(\x0b2\x14.prot\
    ocol.RemoteNodeR\x05nodesB\0:\0\"K\n\x0cClientResult\x12\x1f\n\nmessage_\
    id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12\x18\n\x06result\x18\x02\x20\x01\
    (\x0cR\x06resultB\0:\0\"_\n\tClientErr\x12\x1f\n\nmessage_id\x18\x01\x20\
    \x01(\tR\tmessageIdB\0\x12/\n\x04code\x18\x02\x20\x01(\x0e2\x19.protocol\
    .ClientErrorCodeR\x04codeB\0:\0\")\n\x04Ping\x12\x1f\n\nmessage_id\x18\
    \x01\x20\x01(\tR\tmessageIdB\0:\0\")\n\x04Pong\x12\x1f\n\nmessage_id\x18\
    \x01\x20\x01(\tR\tmessageIdB\0:\0\"\x88\x01\n\x0bCreateActor\x12\x1f\n\n\
    message_id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12\x1b\n\x08actor_id\x18\
    \x02\x20\x01(\tR\x07actorIdB\0\x12\x1f\n\nactor_type\x18\x03\x20\x01(\tR\
    \tactorTypeB\0\x12\x18\n\x06recipe\x18\x04\x20\x01(\x0cR\x06recipeB\0:\0\
    \"K\n\tFindActor\x12\x1f\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageIdB\0\
    \x12\x1b\n\x08actor_id\x18\x02\x20\x01(\tR\x07actorIdB\0:\0\"H\n\x0cActo\
    rAddress\x12\x1b\n\x08actor_id\x18\x01\x20\x01(\tR\x07actorIdB\0\x12\x19\
    \n\x07node_id\x18\x02\x20\x01(\tR\x06nodeIdB\0:\0\"\x91\x01\n\x0eMessage\
    Request\x12\x1f\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12#\n\
    \x0chandler_type\x18\x02\x20\x01(\tR\x0bhandlerTypeB\0\x12\x1b\n\x08acto\
    r_id\x18\x03\x20\x01(\tR\x07actorIdB\0\x12\x1a\n\x07message\x18\x04\x20\
    \x01(\x0cR\x07messageB\0:\0\"u\n\x10SessionHandshake\x12\x19\n\x07node_i\
    d\x18\x01\x20\x01(\tR\x06nodeIdB\0\x12,\n\x05nodes\x18\x02\x20\x03(\x0b2\
    \x14.protocol.RemoteNodeR\x05nodesB\0\x12\x16\n\x05token\x18\x03\x20\x01\
    (\x0cR\x05tokenB\0:\0*~\n\x05Event\x12\x08\n\x04Exit\x10\0\x12\r\n\tHand\
    shake\x10\x01\x12\n\n\x06Result\x10\x02\x12\x07\n\x03Err\x10\x03\x12\x08\
    \n\x04Ping\x10\x04\x12\x08\n\x04Pong\x10\x05\x12\x0f\n\x0bCreateActor\
    \x10\x06\x12\r\n\tFindActor\x10\x07\x12\x11\n\rRegisterActor\x10\x08\x1a\
    \0*?\n\x0fClientErrorCode\x12\x14\n\x10ActorUnavailable\x10\0\x12\x14\n\
    \x10ProcessingFailed\x10\x01\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
