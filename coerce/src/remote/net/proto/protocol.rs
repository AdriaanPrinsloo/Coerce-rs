// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct RemoteNode {
    // message fields
    pub node_id: u64,
    pub addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteNode {
    fn default() -> &'a RemoteNode {
        <RemoteNode as ::protobuf::Message>::default_instance()
    }
}

impl RemoteNode {
    pub fn new() -> RemoteNode {
        ::std::default::Default::default()
    }

    // uint64 node_id = 1;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // string addr = 2;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoteNode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteNode {
        RemoteNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &RemoteNode| { &m.node_id },
                |m: &mut RemoteNode| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &RemoteNode| { &m.addr },
                |m: &mut RemoteNode| { &mut m.addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteNode>(
                "RemoteNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteNode {
        static instance: ::protobuf::rt::LazyV2<RemoteNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteNode::new)
    }
}

impl ::protobuf::Clear for RemoteNode {
    fn clear(&mut self) {
        self.node_id = 0;
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientHandshake {
    // message fields
    pub node_id: u64,
    pub nodes: ::protobuf::RepeatedField<RemoteNode>,
    pub node_tag: ::std::string::String,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientHandshake {
    fn default() -> &'a ClientHandshake {
        <ClientHandshake as ::protobuf::Message>::default_instance()
    }
}

impl ClientHandshake {
    pub fn new() -> ClientHandshake {
        ::std::default::Default::default()
    }

    // uint64 node_id = 1;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // repeated .coerce.remote.net.protocol.RemoteNode nodes = 2;


    pub fn get_nodes(&self) -> &[RemoteNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<RemoteNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<RemoteNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<RemoteNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // string node_tag = 3;


    pub fn get_node_tag(&self) -> &str {
        &self.node_tag
    }
    pub fn clear_node_tag(&mut self) {
        self.node_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_tag(&mut self, v: ::std::string::String) {
        self.node_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_tag(&mut self) -> &mut ::std::string::String {
        &mut self.node_tag
    }

    // Take field
    pub fn take_node_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_tag, ::std::string::String::new())
    }

    // string trace_id = 4;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClientHandshake {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_tag)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_tag);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        for v in &self.nodes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.node_tag.is_empty() {
            os.write_string(3, &self.node_tag)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(4, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientHandshake {
        ClientHandshake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &ClientHandshake| { &m.node_id },
                |m: &mut ClientHandshake| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteNode>>(
                "nodes",
                |m: &ClientHandshake| { &m.nodes },
                |m: &mut ClientHandshake| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_tag",
                |m: &ClientHandshake| { &m.node_tag },
                |m: &mut ClientHandshake| { &mut m.node_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &ClientHandshake| { &m.trace_id },
                |m: &mut ClientHandshake| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientHandshake>(
                "ClientHandshake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientHandshake {
        static instance: ::protobuf::rt::LazyV2<ClientHandshake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientHandshake::new)
    }
}

impl ::protobuf::Clear for ClientHandshake {
    fn clear(&mut self) {
        self.node_id = 0;
        self.nodes.clear();
        self.node_tag.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientHandshake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientResult {
    // message fields
    pub message_id: ::std::string::String,
    pub result: ::std::vec::Vec<u8>,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientResult {
    fn default() -> &'a ClientResult {
        <ClientResult as ::protobuf::Message>::default_instance()
    }
}

impl ClientResult {
    pub fn new() -> ClientResult {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // bytes result = 2;


    pub fn get_result(&self) -> &[u8] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<u8>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }

    // string trace_id = 3;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClientResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.result);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.result.is_empty() {
            os.write_bytes(2, &self.result)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientResult {
        ClientResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &ClientResult| { &m.message_id },
                |m: &mut ClientResult| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "result",
                |m: &ClientResult| { &m.result },
                |m: &mut ClientResult| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &ClientResult| { &m.trace_id },
                |m: &mut ClientResult| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientResult>(
                "ClientResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientResult {
        static instance: ::protobuf::rt::LazyV2<ClientResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientResult::new)
    }
}

impl ::protobuf::Clear for ClientResult {
    fn clear(&mut self) {
        self.message_id.clear();
        self.result.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientErr {
    // message fields
    pub message_id: ::std::string::String,
    pub code: ClientErrorCode,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientErr {
    fn default() -> &'a ClientErr {
        <ClientErr as ::protobuf::Message>::default_instance()
    }
}

impl ClientErr {
    pub fn new() -> ClientErr {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // .coerce.remote.net.protocol.ClientErrorCode code = 2;


    pub fn get_code(&self) -> ClientErrorCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = ClientErrorCode::ActorUnavailable;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ClientErrorCode) {
        self.code = v;
    }

    // string trace_id = 3;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClientErr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if self.code != ClientErrorCode::ActorUnavailable {
            my_size += ::protobuf::rt::enum_size(2, self.code);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if self.code != ClientErrorCode::ActorUnavailable {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientErr {
        ClientErr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &ClientErr| { &m.message_id },
                |m: &mut ClientErr| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientErrorCode>>(
                "code",
                |m: &ClientErr| { &m.code },
                |m: &mut ClientErr| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &ClientErr| { &m.trace_id },
                |m: &mut ClientErr| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientErr>(
                "ClientErr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientErr {
        static instance: ::protobuf::rt::LazyV2<ClientErr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientErr::new)
    }
}

impl ::protobuf::Clear for ClientErr {
    fn clear(&mut self) {
        self.message_id.clear();
        self.code = ClientErrorCode::ActorUnavailable;
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientErr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientErr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub message_id: ::std::string::String,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string trace_id = 2;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &Ping| { &m.message_id },
                |m: &mut Ping| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &Ping| { &m.trace_id },
                |m: &mut Ping| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.message_id.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pong {
    // message fields
    pub message_id: ::std::string::String,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string trace_id = 2;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &Pong| { &m.message_id },
                |m: &mut Pong| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &Pong| { &m.trace_id },
                |m: &mut Pong| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pong>(
                "Pong",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pong {
        static instance: ::protobuf::rt::LazyV2<Pong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pong::new)
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.message_id.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateActor {
    // message fields
    pub message_id: ::std::string::String,
    pub actor_id: ::std::string::String,
    pub actor_type: ::std::string::String,
    pub recipe: ::std::vec::Vec<u8>,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateActor {
    fn default() -> &'a CreateActor {
        <CreateActor as ::protobuf::Message>::default_instance()
    }
}

impl CreateActor {
    pub fn new() -> CreateActor {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string actor_id = 2;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // string actor_type = 3;


    pub fn get_actor_type(&self) -> &str {
        &self.actor_type
    }
    pub fn clear_actor_type(&mut self) {
        self.actor_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_type(&mut self, v: ::std::string::String) {
        self.actor_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_type(&mut self) -> &mut ::std::string::String {
        &mut self.actor_type
    }

    // Take field
    pub fn take_actor_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_type, ::std::string::String::new())
    }

    // bytes recipe = 4;


    pub fn get_recipe(&self) -> &[u8] {
        &self.recipe
    }
    pub fn clear_recipe(&mut self) {
        self.recipe.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipe(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipe = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipe(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.recipe
    }

    // Take field
    pub fn take_recipe(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.recipe, ::std::vec::Vec::new())
    }

    // string trace_id = 5;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateActor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.recipe)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.actor_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_type);
        }
        if !self.recipe.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.recipe);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.actor_type.is_empty() {
            os.write_string(3, &self.actor_type)?;
        }
        if !self.recipe.is_empty() {
            os.write_bytes(4, &self.recipe)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(5, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateActor {
        CreateActor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &CreateActor| { &m.message_id },
                |m: &mut CreateActor| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &CreateActor| { &m.actor_id },
                |m: &mut CreateActor| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_type",
                |m: &CreateActor| { &m.actor_type },
                |m: &mut CreateActor| { &mut m.actor_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "recipe",
                |m: &CreateActor| { &m.recipe },
                |m: &mut CreateActor| { &mut m.recipe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &CreateActor| { &m.trace_id },
                |m: &mut CreateActor| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateActor>(
                "CreateActor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateActor {
        static instance: ::protobuf::rt::LazyV2<CreateActor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateActor::new)
    }
}

impl ::protobuf::Clear for CreateActor {
    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.actor_type.clear();
        self.recipe.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateActor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateActor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FindActor {
    // message fields
    pub message_id: ::std::string::String,
    pub actor_id: ::std::string::String,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FindActor {
    fn default() -> &'a FindActor {
        <FindActor as ::protobuf::Message>::default_instance()
    }
}

impl FindActor {
    pub fn new() -> FindActor {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string actor_id = 2;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // string trace_id = 3;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FindActor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FindActor {
        FindActor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &FindActor| { &m.message_id },
                |m: &mut FindActor| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &FindActor| { &m.actor_id },
                |m: &mut FindActor| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &FindActor| { &m.trace_id },
                |m: &mut FindActor| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FindActor>(
                "FindActor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FindActor {
        static instance: ::protobuf::rt::LazyV2<FindActor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FindActor::new)
    }
}

impl ::protobuf::Clear for FindActor {
    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FindActor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FindActor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorAddress {
    // message fields
    pub actor_id: ::std::string::String,
    pub node_id: u64,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorAddress {
    fn default() -> &'a ActorAddress {
        <ActorAddress as ::protobuf::Message>::default_instance()
    }
}

impl ActorAddress {
    pub fn new() -> ActorAddress {
        ::std::default::Default::default()
    }

    // string actor_id = 1;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // uint64 node_id = 2;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // string trace_id = 3;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActorAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.actor_id);
        }
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actor_id.is_empty() {
            os.write_string(1, &self.actor_id)?;
        }
        if self.node_id != 0 {
            os.write_uint64(2, self.node_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorAddress {
        ActorAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &ActorAddress| { &m.actor_id },
                |m: &mut ActorAddress| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &ActorAddress| { &m.node_id },
                |m: &mut ActorAddress| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &ActorAddress| { &m.trace_id },
                |m: &mut ActorAddress| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorAddress>(
                "ActorAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorAddress {
        static instance: ::protobuf::rt::LazyV2<ActorAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorAddress::new)
    }
}

impl ::protobuf::Clear for ActorAddress {
    fn clear(&mut self) {
        self.actor_id.clear();
        self.node_id = 0;
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRequest {
    // message fields
    pub message_id: ::std::string::String,
    pub handler_type: ::std::string::String,
    pub actor_id: ::std::string::String,
    pub message: ::std::vec::Vec<u8>,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRequest {
    fn default() -> &'a MessageRequest {
        <MessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageRequest {
    pub fn new() -> MessageRequest {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // string handler_type = 2;


    pub fn get_handler_type(&self) -> &str {
        &self.handler_type
    }
    pub fn clear_handler_type(&mut self) {
        self.handler_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_handler_type(&mut self, v: ::std::string::String) {
        self.handler_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler_type(&mut self) -> &mut ::std::string::String {
        &mut self.handler_type
    }

    // Take field
    pub fn take_handler_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handler_type, ::std::string::String::new())
    }

    // string actor_id = 3;


    pub fn get_actor_id(&self) -> &str {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::string::String) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::string::String {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_id, ::std::string::String::new())
    }

    // bytes message = 4;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }

    // string trace_id = 5;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handler_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.handler_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handler_type);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_id);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.message);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.handler_type.is_empty() {
            os.write_string(2, &self.handler_type)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(3, &self.actor_id)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(4, &self.message)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(5, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRequest {
        MessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &MessageRequest| { &m.message_id },
                |m: &mut MessageRequest| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "handler_type",
                |m: &MessageRequest| { &m.handler_type },
                |m: &mut MessageRequest| { &mut m.handler_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_id",
                |m: &MessageRequest| { &m.actor_id },
                |m: &mut MessageRequest| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &MessageRequest| { &m.message },
                |m: &mut MessageRequest| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &MessageRequest| { &m.trace_id },
                |m: &mut MessageRequest| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRequest>(
                "MessageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageRequest {
        static instance: ::protobuf::rt::LazyV2<MessageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageRequest::new)
    }
}

impl ::protobuf::Clear for MessageRequest {
    fn clear(&mut self) {
        self.message_id.clear();
        self.handler_type.clear();
        self.actor_id.clear();
        self.message.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionHandshake {
    // message fields
    pub node_id: u64,
    pub nodes: ::protobuf::RepeatedField<RemoteNode>,
    pub token: ::std::vec::Vec<u8>,
    pub node_tag: ::std::string::String,
    pub client_type: ClientType,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionHandshake {
    fn default() -> &'a SessionHandshake {
        <SessionHandshake as ::protobuf::Message>::default_instance()
    }
}

impl SessionHandshake {
    pub fn new() -> SessionHandshake {
        ::std::default::Default::default()
    }

    // uint64 node_id = 1;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // repeated .coerce.remote.net.protocol.RemoteNode nodes = 2;


    pub fn get_nodes(&self) -> &[RemoteNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<RemoteNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<RemoteNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<RemoteNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // bytes token = 3;


    pub fn get_token(&self) -> &[u8] {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token, ::std::vec::Vec::new())
    }

    // string node_tag = 4;


    pub fn get_node_tag(&self) -> &str {
        &self.node_tag
    }
    pub fn clear_node_tag(&mut self) {
        self.node_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_tag(&mut self, v: ::std::string::String) {
        self.node_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_tag(&mut self) -> &mut ::std::string::String {
        &mut self.node_tag
    }

    // Take field
    pub fn take_node_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_tag, ::std::string::String::new())
    }

    // .coerce.remote.net.protocol.ClientType client_type = 5;


    pub fn get_client_type(&self) -> ClientType {
        self.client_type
    }
    pub fn clear_client_type(&mut self) {
        self.client_type = ClientType::Client;
    }

    // Param is passed by value, moved
    pub fn set_client_type(&mut self, v: ClientType) {
        self.client_type = v;
    }

    // string trace_id = 6;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SessionHandshake {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_tag)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.client_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token);
        }
        if !self.node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_tag);
        }
        if self.client_type != ClientType::Client {
            my_size += ::protobuf::rt::enum_size(5, self.client_type);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        for v in &self.nodes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.token.is_empty() {
            os.write_bytes(3, &self.token)?;
        }
        if !self.node_tag.is_empty() {
            os.write_string(4, &self.node_tag)?;
        }
        if self.client_type != ClientType::Client {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.client_type))?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(6, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionHandshake {
        SessionHandshake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &SessionHandshake| { &m.node_id },
                |m: &mut SessionHandshake| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteNode>>(
                "nodes",
                |m: &SessionHandshake| { &m.nodes },
                |m: &mut SessionHandshake| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &SessionHandshake| { &m.token },
                |m: &mut SessionHandshake| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_tag",
                |m: &SessionHandshake| { &m.node_tag },
                |m: &mut SessionHandshake| { &mut m.node_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientType>>(
                "client_type",
                |m: &SessionHandshake| { &m.client_type },
                |m: &mut SessionHandshake| { &mut m.client_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &SessionHandshake| { &m.trace_id },
                |m: &mut SessionHandshake| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionHandshake>(
                "SessionHandshake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionHandshake {
        static instance: ::protobuf::rt::LazyV2<SessionHandshake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionHandshake::new)
    }
}

impl ::protobuf::Clear for SessionHandshake {
    fn clear(&mut self) {
        self.node_id = 0;
        self.nodes.clear();
        self.token.clear();
        self.node_tag.clear();
        self.client_type = ClientType::Client;
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionHandshake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamPublish {
    // message fields
    pub topic: ::std::string::String,
    pub key: ::std::string::String,
    pub message: ::std::vec::Vec<u8>,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamPublish {
    fn default() -> &'a StreamPublish {
        <StreamPublish as ::protobuf::Message>::default_instance()
    }
}

impl StreamPublish {
    pub fn new() -> StreamPublish {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // string key = 2;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // bytes message = 3;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }

    // string trace_id = 4;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamPublish {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(4, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamPublish {
        StreamPublish::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &StreamPublish| { &m.topic },
                |m: &mut StreamPublish| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StreamPublish| { &m.key },
                |m: &mut StreamPublish| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &StreamPublish| { &m.message },
                |m: &mut StreamPublish| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &StreamPublish| { &m.trace_id },
                |m: &mut StreamPublish| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamPublish>(
                "StreamPublish",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamPublish {
        static instance: ::protobuf::rt::LazyV2<StreamPublish> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamPublish::new)
    }
}

impl ::protobuf::Clear for StreamPublish {
    fn clear(&mut self) {
        self.topic.clear();
        self.key.clear();
        self.message.clear();
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamPublish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamPublish {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewNodeEvent {
    // message fields
    pub node_id: u64,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewNodeEvent {
    fn default() -> &'a NewNodeEvent {
        <NewNodeEvent as ::protobuf::Message>::default_instance()
    }
}

impl NewNodeEvent {
    pub fn new() -> NewNodeEvent {
        ::std::default::Default::default()
    }

    // uint64 node_id = 1;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // string trace_id = 2;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NewNodeEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewNodeEvent {
        NewNodeEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &NewNodeEvent| { &m.node_id },
                |m: &mut NewNodeEvent| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &NewNodeEvent| { &m.trace_id },
                |m: &mut NewNodeEvent| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewNodeEvent>(
                "NewNodeEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewNodeEvent {
        static instance: ::protobuf::rt::LazyV2<NewNodeEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewNodeEvent::new)
    }
}

impl ::protobuf::Clear for NewNodeEvent {
    fn clear(&mut self) {
        self.node_id = 0;
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewNodeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewNodeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeRemovedEvent {
    // message fields
    pub node_id: u64,
    pub trace_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeRemovedEvent {
    fn default() -> &'a NodeRemovedEvent {
        <NodeRemovedEvent as ::protobuf::Message>::default_instance()
    }
}

impl NodeRemovedEvent {
    pub fn new() -> NodeRemovedEvent {
        ::std::default::Default::default()
    }

    // uint64 node_id = 1;


    pub fn get_node_id(&self) -> u64 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u64) {
        self.node_id = v;
    }

    // string trace_id = 2;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeRemovedEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeRemovedEvent {
        NodeRemovedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "node_id",
                |m: &NodeRemovedEvent| { &m.node_id },
                |m: &mut NodeRemovedEvent| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_id",
                |m: &NodeRemovedEvent| { &m.trace_id },
                |m: &mut NodeRemovedEvent| { &mut m.trace_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeRemovedEvent>(
                "NodeRemovedEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeRemovedEvent {
        static instance: ::protobuf::rt::LazyV2<NodeRemovedEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeRemovedEvent::new)
    }
}

impl ::protobuf::Clear for NodeRemovedEvent {
    fn clear(&mut self) {
        self.node_id = 0;
        self.trace_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeRemovedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeRemovedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RaftRequest {
    // message fields
    pub message_id: ::std::string::String,
    pub request_type: u32,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RaftRequest {
    fn default() -> &'a RaftRequest {
        <RaftRequest as ::protobuf::Message>::default_instance()
    }
}

impl RaftRequest {
    pub fn new() -> RaftRequest {
        ::std::default::Default::default()
    }

    // string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // uint32 request_type = 2;


    pub fn get_request_type(&self) -> u32 {
        self.request_type
    }
    pub fn clear_request_type(&mut self) {
        self.request_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_type(&mut self, v: u32) {
        self.request_type = v;
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RaftRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if self.request_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.request_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if self.request_type != 0 {
            os.write_uint32(2, self.request_type)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RaftRequest {
        RaftRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &RaftRequest| { &m.message_id },
                |m: &mut RaftRequest| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_type",
                |m: &RaftRequest| { &m.request_type },
                |m: &mut RaftRequest| { &mut m.request_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &RaftRequest| { &m.payload },
                |m: &mut RaftRequest| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RaftRequest>(
                "RaftRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RaftRequest {
        static instance: ::protobuf::rt::LazyV2<RaftRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RaftRequest::new)
    }
}

impl ::protobuf::Clear for RaftRequest {
    fn clear(&mut self) {
        self.message_id.clear();
        self.request_type = 0;
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RaftRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Event {
    Exit = 0,
    Handshake = 1,
    Result = 2,
    Err = 3,
    Ping = 4,
    Pong = 5,
    CreateActor = 6,
    FindActor = 7,
    RegisterActor = 8,
    NotifyActor = 9,
    StreamPublish = 10,
    Raft = 11,
}

impl ::protobuf::ProtobufEnum for Event {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event> {
        match value {
            0 => ::std::option::Option::Some(Event::Exit),
            1 => ::std::option::Option::Some(Event::Handshake),
            2 => ::std::option::Option::Some(Event::Result),
            3 => ::std::option::Option::Some(Event::Err),
            4 => ::std::option::Option::Some(Event::Ping),
            5 => ::std::option::Option::Some(Event::Pong),
            6 => ::std::option::Option::Some(Event::CreateActor),
            7 => ::std::option::Option::Some(Event::FindActor),
            8 => ::std::option::Option::Some(Event::RegisterActor),
            9 => ::std::option::Option::Some(Event::NotifyActor),
            10 => ::std::option::Option::Some(Event::StreamPublish),
            11 => ::std::option::Option::Some(Event::Raft),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Event] = &[
            Event::Exit,
            Event::Handshake,
            Event::Result,
            Event::Err,
            Event::Ping,
            Event::Pong,
            Event::CreateActor,
            Event::FindActor,
            Event::RegisterActor,
            Event::NotifyActor,
            Event::StreamPublish,
            Event::Raft,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Event>("Event", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Event {
}

impl ::std::default::Default for Event {
    fn default() -> Self {
        Event::Exit
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientType {
    Client = 0,
    Worker = 1,
}

impl ::protobuf::ProtobufEnum for ClientType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            0 => ::std::option::Option::Some(ClientType::Client),
            1 => ::std::option::Option::Some(ClientType::Worker),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientType] = &[
            ClientType::Client,
            ClientType::Worker,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClientType>("ClientType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClientType {
}

impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::Client
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientErrorCode {
    ActorUnavailable = 0,
    ProcessingFailed = 1,
}

impl ::protobuf::ProtobufEnum for ClientErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ClientErrorCode::ActorUnavailable),
            1 => ::std::option::Option::Some(ClientErrorCode::ProcessingFailed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientErrorCode] = &[
            ClientErrorCode::ActorUnavailable,
            ClientErrorCode::ProcessingFailed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClientErrorCode>("ClientErrorCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClientErrorCode {
}

impl ::std::default::Default for ClientErrorCode {
    fn default() -> Self {
        ClientErrorCode::ActorUnavailable
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SystemEvent {
    ClusterNewNode = 0,
    ClusterNodeRemoved = 1,
}

impl ::protobuf::ProtobufEnum for SystemEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SystemEvent> {
        match value {
            0 => ::std::option::Option::Some(SystemEvent::ClusterNewNode),
            1 => ::std::option::Option::Some(SystemEvent::ClusterNodeRemoved),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SystemEvent] = &[
            SystemEvent::ClusterNewNode,
            SystemEvent::ClusterNodeRemoved,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SystemEvent>("SystemEvent", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SystemEvent {
}

impl ::std::default::Default for SystemEvent {
    fn default() -> Self {
        SystemEvent::ClusterNewNode
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eprotocol.proto\x12\x1acoerce.remote.net.protocol\"?\n\nRemoteNode\
    \x12\x19\n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeIdB\0\x12\x14\n\x04ad\
    dr\x18\x02\x20\x01(\tR\x04addrB\0:\0\"\xa8\x01\n\x0fClientHandshake\x12\
    \x19\n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeIdB\0\x12>\n\x05nodes\x18\
    \x02\x20\x03(\x0b2&.coerce.remote.net.protocol.RemoteNodeR\x05nodesB\0\
    \x12\x1b\n\x08node_tag\x18\x03\x20\x01(\tR\x07nodeTagB\0\x12\x1b\n\x08tr\
    ace_id\x18\x04\x20\x01(\tR\x07traceIdB\0:\0\"h\n\x0cClientResult\x12\x1f\
    \n\nmessage_id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12\x18\n\x06result\x18\
    \x02\x20\x01(\x0cR\x06resultB\0\x12\x1b\n\x08trace_id\x18\x03\x20\x01(\t\
    R\x07traceIdB\0:\0\"\x8e\x01\n\tClientErr\x12\x1f\n\nmessage_id\x18\x01\
    \x20\x01(\tR\tmessageIdB\0\x12A\n\x04code\x18\x02\x20\x01(\x0e2+.coerce.\
    remote.net.protocol.ClientErrorCodeR\x04codeB\0\x12\x1b\n\x08trace_id\
    \x18\x03\x20\x01(\tR\x07traceIdB\0:\0\"F\n\x04Ping\x12\x1f\n\nmessage_id\
    \x18\x01\x20\x01(\tR\tmessageIdB\0\x12\x1b\n\x08trace_id\x18\x02\x20\x01\
    (\tR\x07traceIdB\0:\0\"F\n\x04Pong\x12\x1f\n\nmessage_id\x18\x01\x20\x01\
    (\tR\tmessageIdB\0\x12\x1b\n\x08trace_id\x18\x02\x20\x01(\tR\x07traceIdB\
    \0:\0\"\xa5\x01\n\x0bCreateActor\x12\x1f\n\nmessage_id\x18\x01\x20\x01(\
    \tR\tmessageIdB\0\x12\x1b\n\x08actor_id\x18\x02\x20\x01(\tR\x07actorIdB\
    \0\x12\x1f\n\nactor_type\x18\x03\x20\x01(\tR\tactorTypeB\0\x12\x18\n\x06\
    recipe\x18\x04\x20\x01(\x0cR\x06recipeB\0\x12\x1b\n\x08trace_id\x18\x05\
    \x20\x01(\tR\x07traceIdB\0:\0\"h\n\tFindActor\x12\x1f\n\nmessage_id\x18\
    \x01\x20\x01(\tR\tmessageIdB\0\x12\x1b\n\x08actor_id\x18\x02\x20\x01(\tR\
    \x07actorIdB\0\x12\x1b\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceIdB\0:\
    \0\"e\n\x0cActorAddress\x12\x1b\n\x08actor_id\x18\x01\x20\x01(\tR\x07act\
    orIdB\0\x12\x19\n\x07node_id\x18\x02\x20\x01(\x04R\x06nodeIdB\0\x12\x1b\
    \n\x08trace_id\x18\x03\x20\x01(\tR\x07traceIdB\0:\0\"\xae\x01\n\x0eMessa\
    geRequest\x12\x1f\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12#\n\
    \x0chandler_type\x18\x02\x20\x01(\tR\x0bhandlerTypeB\0\x12\x1b\n\x08acto\
    r_id\x18\x03\x20\x01(\tR\x07actorIdB\0\x12\x1a\n\x07message\x18\x04\x20\
    \x01(\x0cR\x07messageB\0\x12\x1b\n\x08trace_id\x18\x05\x20\x01(\tR\x07tr\
    aceIdB\0:\0\"\x8c\x02\n\x10SessionHandshake\x12\x19\n\x07node_id\x18\x01\
    \x20\x01(\x04R\x06nodeIdB\0\x12>\n\x05nodes\x18\x02\x20\x03(\x0b2&.coerc\
    e.remote.net.protocol.RemoteNodeR\x05nodesB\0\x12\x16\n\x05token\x18\x03\
    \x20\x01(\x0cR\x05tokenB\0\x12\x1b\n\x08node_tag\x18\x04\x20\x01(\tR\x07\
    nodeTagB\0\x12I\n\x0bclient_type\x18\x05\x20\x01(\x0e2&.coerce.remote.ne\
    t.protocol.ClientTypeR\nclientTypeB\0\x12\x1b\n\x08trace_id\x18\x06\x20\
    \x01(\tR\x07traceIdB\0:\0\"v\n\rStreamPublish\x12\x16\n\x05topic\x18\x01\
    \x20\x01(\tR\x05topicB\0\x12\x12\n\x03key\x18\x02\x20\x01(\tR\x03keyB\0\
    \x12\x1a\n\x07message\x18\x03\x20\x01(\x0cR\x07messageB\0\x12\x1b\n\x08t\
    race_id\x18\x04\x20\x01(\tR\x07traceIdB\0:\0\"H\n\x0cNewNodeEvent\x12\
    \x19\n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeIdB\0\x12\x1b\n\x08trace_\
    id\x18\x02\x20\x01(\tR\x07traceIdB\0:\0\"L\n\x10NodeRemovedEvent\x12\x19\
    \n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeIdB\0\x12\x1b\n\x08trace_id\
    \x18\x02\x20\x01(\tR\x07traceIdB\0:\0\"q\n\x0bRaftRequest\x12\x1f\n\nmes\
    sage_id\x18\x01\x20\x01(\tR\tmessageIdB\0\x12#\n\x0crequest_type\x18\x02\
    \x20\x01(\rR\x0brequestTypeB\0\x12\x1a\n\x07payload\x18\x03\x20\x01(\x0c\
    R\x07payloadB\0:\0*\xac\x01\n\x05Event\x12\x08\n\x04Exit\x10\0\x12\r\n\t\
    Handshake\x10\x01\x12\n\n\x06Result\x10\x02\x12\x07\n\x03Err\x10\x03\x12\
    \x08\n\x04Ping\x10\x04\x12\x08\n\x04Pong\x10\x05\x12\x0f\n\x0bCreateActo\
    r\x10\x06\x12\r\n\tFindActor\x10\x07\x12\x11\n\rRegisterActor\x10\x08\
    \x12\x0f\n\x0bNotifyActor\x10\t\x12\x11\n\rStreamPublish\x10\n\x12\x08\n\
    \x04Raft\x10\x0b\x1a\0*&\n\nClientType\x12\n\n\x06Client\x10\0\x12\n\n\
    \x06Worker\x10\x01\x1a\0*?\n\x0fClientErrorCode\x12\x14\n\x10ActorUnavai\
    lable\x10\0\x12\x14\n\x10ProcessingFailed\x10\x01\x1a\0*;\n\x0bSystemEve\
    nt\x12\x12\n\x0eClusterNewNode\x10\0\x12\x16\n\x12ClusterNodeRemoved\x10\
    \x01\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
